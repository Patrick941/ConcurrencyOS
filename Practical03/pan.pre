# 1 "writers-and-reader.pml"
# 1 "<built-in>"
# 1 "<command-line>"
# 31 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 32 "<command-line>" 2
# 1 "writers-and-reader.pml"


# 1 "pthreads.pml" 1




mtype = { unlocked, locked } ;


typedef mutexData {
  mtype mstate;
  byte mid;

}


typedef condvarData {
  mtype cstate;

}

mutexData mtx;

condvarData cvars[2];



inline initsync() {
  mtx.mstate = unlocked;
  cvars[0].cstate = true;
  cvars[1].cstate = true;

}


inline lock(m) {
  printf("@@@ %d LOCKING : state is %e\n",_pid,m.mstate)
    do
    :: atomic{m.mstate == unlocked -> m.mid = _pid; m.mstate = locked; break;}
    :: else;
    od;
  printf("@@@ %d LOCKED : state is %e\n",_pid,m.mstate)
}


inline unlock(m) {
  atomic{
    printf("@@@ %d UNLOCKING : state is %e\n",_pid,m.mstate)
    m.mstate = unlocked;
    m.mid = 255;
    printf("@@@ %d UNLOCKED : state is %e\n",_pid,m.mstate)
  }
}


inline wait(c,m) {
  printf("@@@ %d WAIT for cond[%d]=%d with mutex=%e\n",_pid,c, cvars[c].cstate,m.mstate)
  unlock(m);
  cvars[c].cstate = locked;
  do
  :: atomic{cvars[c].cstate == unlocked -> break;}
  :: else;
  od;
  lock(m);
  printf("@@@ %d DONE with cond[%d]=%d with mutex=%e\n",_pid, c,cvars[c].cstate,m.mstate)
}


inline signal(c) {
  atomic{
    printf("@@@ %d SIGNAL cond[%d]=%d\n",_pid,c,cvars[c].cstate)
    cvars[c].cstate = unlocked;
    printf("@@@ %d SIGNALLED cond[%d]=%d\n",_pid,c,cvars[c].cstate)
  }
}
# 4 "writers-and-reader.pml" 2







byte buffer[4];
byte in,out;
bool bfull,bempty;

inline zerobuffer() {
  in = 0;
  do
  :: in < 4 -> buffer[in] = 0; in++
  :: else -> in = 0; break
  od
  out = 4 -1;
  bfull = false; bempty = true;
  printf("buffer zeroed\n")
}

byte six;

inline showbuffer(){
  atomic{
    printf("@@@ %d BUFFER in:%d, out:%d, empty:%d, full:%d [|",_pid,in,out,bempty,bfull);
    six = 0;
    do
      :: six < 4 -> printf(" %d |",buffer[six]); six++;
      :: else -> printf("]\n"); break;
    od
  }
}



inline insert(x) {
  assert(!bfull);
  buffer[in] = x;
  printf("@@@ %d INSERT buf[%d] := %d\n",_pid,in,x);
  bempty = false;
  bfull = (in == out);
  in = ((in+1) % 4);
  showbuffer();
}

byte cout;

inline extract() {
  assert(!bempty);
  out = ((out+1) % 4);
  cout = buffer[out]; buffer[out] = 0;
  printf("@@@ %d **** EXTRACT cout := buf[%d] is %d\n",_pid,out,cout);
  bfull = false;
  bempty = (((out+1) % 4) == in)
  showbuffer();
}




inline produce(p) {
  lock(mtx);
  printf("Lock was exited by process %d\n", _pid);
  assert(mtx.mid == _pid);
  do
  :: !bfull -> break;
  :: else -> wait(0,mtx);
  od
  assert(mtx.mid == _pid);
  insert(p);
  progress_prod:
  signal(1);
  assert(mtx.mid == _pid);
  unlock(mtx);
}



proctype producer(int pno) {
  int p=0;
  do
  :: produce(p+pno); p = (p+2) % 8


  od
}



inline consume() {
  lock(mtx);
  assert(mtx.mid == _pid);
  do
  :: !bempty -> break;
  :: else -> wait(1,mtx);
  od
  assert(mtx.mid == _pid);
  extract();
  progress_cons:
  signal(0);
  assert(mtx.mid == _pid);
  unlock(mtx);
}

proctype consumer() {
  do
  :: consume()
  od
}



init {
  int z;

  printf("A Model of pthreads\n")
  printf("\n Producer-Consumer example\n")
  zerobuffer()
  showbuffer()
  initsync()
  run producer(1)
  run producer(2)
  run consumer()
}
